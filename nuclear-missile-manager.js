/* 
нужно запустить ракеты по очереди с интервалом в секунду
сейчас этот код запускает последнюю ракету 5 раз с интервалом в секунду 

то есть нужно чтобы у нас в консоли было "0, 1, 2, 3, 4"
сейчас вместо этого у нас "5, 5, 5, 5, 5"

что здесь вообще происходит? почему в консоли 5 раз выводится 5? Как работает этот код?
Сейчас будем разбираться.

Итак, мы запускам функцию launchAll(). Внутри этой функции выполняется цикл for. 
- заходим в цикл for. i = 0, условие i < 5 выполняется
Выполняется первая итерация цикла. Когда движок видит внутри цикла setTimeout(), 
тогда он отправляет setTimeout() на выполнение в Web APIs. 
Так как в цикле больше ничего нет, то начинается новая итерация цикла.

- i = 1, условие i < 5 выполняется
Выполняется вторая итерация цикла. Когда движок видит внутри цикла setTimeout(), 
тогда он отправляет setTimeout() на выполнение в Web APIs. 
Так как в цикле больше ничего нет, то начинается новая итерация цикла.

- i = 2, условие i < 5 выполняется
- i = 3, условие i < 5 выполняется
- i = 4, условие i < 5 выполняется
- i = 5, условие i < 5 не выполняется, цикл больше работать не будет.

В итоге функция launchAll() полностью завершила свою работу. i сейчас равна 5. 
Параллельно в WebAPIs отработали функции 
setTimeout(function () {
      launchMissile(i);
    }, i * 1000);

Таких функций у нас было 5 штук, так как цикл работал 5 раз, и 5 раз отсылал setTimeout() в Web APIs.
После этого в WebAPIs функции setTimeout() выполнились, и колбэки которые были внутри setTimeout(), попали
в очередь колбэков. В итоге в очереди колбэков у нас сейчас пять launchMissile(i)

Вот эти колбэки висели в очереди и ждали пока отработает синхронный код:

function launchAll(launchMissile) {
  for (var i = 0; i < 5; i++) {
   ... 
  }
}

В итоге этот синхронный код отработал, i = 5, стек вызовов пустой, и теперь event loop помещает в стек вызовов колбэки
launchMissile(i)

Выполняются колбэки launchMissile(i), так как у нас 5 колбэков, и i = 5, то в консоли у нас будет пять раз по 5.

Окей. Как теперь тогда исправить код, чтобы в консоль выводилось "0, 1, 2, 3, 4"?
В чем тут вообще проблема? Проблема видимо в том, что сейчас у нас есть один единственный scope, в котором выполняется наш код.
Этот scope - это область видимости функции launchAll. 
Так как сейчас мы не создаем каждый раз новый scope, когда выполняем цикл for, то и получается, что цикл раз за разом отправляет 
setTimeout() в WebAPIs, а сам в это время выполняется и накапливает значение i. 

Попробуем сделать так, чтобы в теле цикла создавался бы новый scope. Для этого можно использовать IIFE функцию в теле цикла.

- выполняется первая итерация цикла. i = 0, условие i < 5 выполняется
- выполняется IIFE функция в которую мы передаем значение i = 0
- как только движок видит setTimeout, он отправляет setTimeout на выполнение в Web APIs, причем мы передаем setTimeout 
колбэк launchMissile(copyOfI), в котором copyOfI мы передаем сейчас 0
- больше в цикле нет никакого кода, так что начинается новая итерация цикла

- выполняется вторая итерация цикла. i = 1, условие i < 5 выполняется
- выполняется IIFE функция в которую мы передаем значение i = 1
- как только движок видит setTimeout, он отправляет setTimeout на выполнение в Web APIs, причем мы передаем setTimeout 
колбэк launchMissile(copyOfI), в котором copyOfI мы передаем сейчас 1
- больше в цикле нет никакого кода, так что начинается новая итерация цикла

....

- выполняется пятая итерация цикла. i = 4, условие i < 5 выполняется
- выполняется IIFE функция в которую мы передаем значение i = 4
- как только движок видит setTimeout, он отправляет setTimeout на выполнение в Web APIs, причем мы передаем setTimeout 
колбэк launchMissile(copyOfI), в котором copyOfI мы передаем сейчас 4
- больше в цикле нет никакого кода, так что начинается новая итерация цикла

Дальше цикл работать не будет, так как i = 5, и условие i < 5 не выполнится.

Все, наш синхронный код отработал, и теперь будут выполняться колбэки из очереди колбэков. В каждом колбэке значение copyOfI 
будет свое, так что в консоли мы увидим "0, 1, 2, 3, 4"
Все что нам нужно было сделать - это создать отдельный scope внутри цикла for. 

Один из вариантов решения этой задачи заключается еще в присваивании i переменной let. let обладает блочным scope, поэтому если мы будем использовать вот такой код:

for (var i = 0; i < 5; i++) {
      let index = i;
      setTimeout(function () {
        launchMissile(index);
      }, i * 1000);
}

тогда у нас каждый раз в теле цикла будет создаваться новый scope, и у переменной let index будут всегда разные значения
У нас будет 5 разных scope, с 5 разными значениями переменной let index. То есть мы 5 раз создадим новый scope и новую переменную
let index. 

Еще можно просто в условии цикла вместо var сразу использовать let, тогда у нас тоже в теле цикла каждый раз будет 
создаваться новый scope:

for (let i = 0; i < 5; i++) {
      setTimeout(function () {
        launchMissile(i);
      }, i * 1000);
}
*/

function launchMiss(index) {
  console.log(index);
}

function launchAll(launchMissile) {
  for (var i = 0; i < 5; i++) {
    (function (copyOfI) {
      setTimeout(function () {
        launchMissile(copyOfI);
      }, i * 1000);
    })(i);
  }
}

launchAll(launchMiss);
